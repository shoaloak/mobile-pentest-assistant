#
# Copyright (C) 2024 Axel Koolhaas
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import json
import logging
import shutil
import subprocess
import time
from typing import Optional
from device import BaseDevice, DeviceType
from utils.helpers import find_available_host_port, exec_applescript, exec_applestatement, get_project_path
import utils.host_system as host_system

IPROXY_DELAY = 0.3
COMMON_SSH_PORTS = [22, 44]
SSH_FLAGS = [
    # force IPv4 to solve sshd bug "setsockopt TCP_NODELAY: Invalid argument"
    '-4' 
]

class IosDevice(BaseDevice):
    # TODO: create and store SSH key as well?
    # TODO: maybe migrate to better storage solution, like sqlite
    # File to store known port mappings for iproxy
    _port_mapping_file = "port_mappings.json"

    # id is the UniqueDeviceID of the idevice
    def __init__(self, id):
        super().__init__(id, DeviceType.IOS)
        # TODO: should I check if there is already an iproxy?
        self._iproxy_process = None
        self._host_port = find_available_host_port(start_port=2222)
        self._port = self.get_stored_port() or self.find_ssh_port()
        self._name = self.get_device_name()
        self._os_version = self.get_os_version()
        # self.set_os_version(self.get_os_version())

    def connect(self):
        """Start iproxy to forward the SSH port to localhost"""
        if self._iproxy_process is None:
            if self._port is None:
                self._port = self.get_stored_port() or self.find_ssh_port()

            self._iproxy_process = subprocess.Popen(
                [
                    'iproxy',
                    str(self._host_port),
                    str(self._port),
                    '-u', self._id
                ],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            time.sleep(IPROXY_DELAY)

    def disconnect(self):
        if self._iproxy_process:
            self._iproxy_process.terminate()
            self._iproxy_process = None

    def execute_connected_command(self, command):
        #TODO
        pass

    def execute_transient_command(self, command):
        #TODO
        return
        if self._host_port is not None:
            try:
                ssh_command = [
                    'ssh',
                    *SSH_FLAGS,
                    f'-p {self._host_port}',
                    'mobile@localhost'
                ]
                result = subprocess.run(
                    ssh_command,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
                return result.stdout.strip()
            except subprocess.CalledProcessError as e:
                return f"Failed to run command: {e}"
        else:
            return "No open SSH port found for device."
        pass

    def mirror_screen(self):
        if host_system.get_os() != host_system.OperatingSystem.MACOS:
            print("Screen mirroring is only supported on macOS.")
            return
        
        print("Make sure you trust this computer on your iOS device.")
        print("After acceptance, you might need to replug your device.")

        # Starting the player beforehand increases success rate
        exec_applestatement('tell application "QuickTime Player" to activate')
        exec_applestatement('tell application "QuickTime Player" to new movie recording')

        exec_applescript(get_project_path() + '/scripts/mirror.scpt', [self._name])

    def shell(self):
        # Ensure iproxy is running
        if self._iproxy_process is None:
            self.connect()

        if self._host_port is not None:
            ssh_command = [
                shutil.which('ssh'),
                *SSH_FLAGS,
                f'-p {self._host_port}',
                'mobile@localhost'
            ]

            # Open an interactive shell
            try:
                p = subprocess.Popen(ssh_command)
                p.communicate()  # Wait for the SSH session to end
                return p.returncode
            except subprocess.CalledProcessError as e:
                return f"Failed to run command: {e}"
        else:
            return "No open SSH port found for device."
    
    ############################################################################

    def get_stored_port(self) -> Optional[int]:
        try:
            with open(self._port_mapping_file, "r") as file:
                port_mappings = json.load(file)
            return port_mappings.get(self._id)
        except (FileNotFoundError, json.JSONDecodeError):
            # File doesn't exist or is empty
            return None  

    def update_port_mapping(self, port):
        try:
            with open(self._port_mapping_file, "r") as file:
                port_mappings = json.load(file)
        except (FileNotFoundError, json.JSONDecodeError):
            # Create a new dictionary if file doesn't exist
            port_mappings = {}  

        port_mappings[self._id] = port

        with open(self._port_mapping_file, "w") as file:
            json.dump(port_mappings, file)

    def find_ssh_port(self) -> Optional[int]:
        """Try to find an open SSH port on the idevice."""

        for ssh_port in COMMON_SSH_PORTS:
            # Start iproxy in the background with the current port
            self._iproxy_process = subprocess.Popen(
                ['iproxy', str(self._host_port), str(ssh_port), '-u', self._id],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            time.sleep(IPROXY_DELAY)  # Wait for iproxy to establish

            # Try to establish an SSH connection to check if the port is correct
            ssh_command = [
                'ssh',
                *SSH_FLAGS,
                f'-p {self._host_port}',
                '-o ConnectTimeout=1',
                'mobile@localhost',
            ]

            try:
                subprocess.run(
                    ssh_command,
                    timeout=1,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
            except subprocess.TimeoutExpired:
                # If this happens, the port is correct
                self.update_port_mapping(ssh_port)
                return ssh_port

            # Close the incorrect iproxy connection and try another port
            self._iproxy_process.terminate()

        self._iproxy_process = None
        return None

    def get_device_name(self) -> Optional[str]:
        try:
            result = subprocess.check_output(
                ["ideviceinfo", "-u", self._id, "-k", "DeviceName"]
            )
            device_name = result.decode('utf-8').strip()
            return device_name
        except subprocess.CalledProcessError:
            return None

    def get_os_version(self) -> Optional[str]:
        try:
            result = subprocess.check_output(
                ["ideviceinfo", "-u", self._id, "-k", "ProductVersion"]
            )
            device_name = result.decode('utf-8').strip()
            return device_name
        except subprocess.CalledProcessError:
            return None
