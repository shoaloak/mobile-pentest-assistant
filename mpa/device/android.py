"""
Copyright (C) 2024 Axel Koolhaas

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import logging
import select
import shutil
import subprocess
from typing import Optional
from device import BaseDevice, DeviceType

class AndroidDevice(BaseDevice):
    _adb_command_timeout = 0.3

    def __init__(self, id):
        super().__init__(id, DeviceType.ANDROID)
        self._is_virtual = id.startswith("emulator")
        self._adb_process = None
        self._os_version = self.get_os_version()
        self._proxy_active = False

    def __str__(self):
        if (self._is_virtual):
            return f"{self._type.value + ' (virtual)':<20} {self._os_version:<8} {self._id}"
        else:
            return super().__str__()

    
    def connect(self):
        self._adb_process = subprocess.Popen(
            [
                shutil.which('adb'),
                '-s', self._id,
                'shell'
            ],
            stdin=subprocess.PIPE, 
            stdout=subprocess.PIPE, 
            stderr=subprocess.PIPE, 
            text=True,  # Use text mode for strings
            bufsize=1  # buffer lines
        )
    
    def disconnect(self):
        # Check if adb process has been set
        if self._adb_process is None:
            logging.info("No connection established.")
            return
        
        # Check if adb process is still running
        if self._adb_process.poll() is None:
            self._adb_process.terminate()

    def execute_connected_command(self, command) -> Optional[str]:
        if self._adb_process is None or self._adb_process.poll() is not None:
            return "No connection established."

        try:
            # Send command
            self._adb_process.stdin.write(command + "\n")
            self._adb_process.stdin.flush() # Make sure the command is sent

            # Read the response
            lines = []
            while True:
                # Use select to wait for input to be available on stdout or stderr
                readable, writable, exceptional = select.select(
                    [self._adb_process.stdout, self._adb_process.stderr],
                    [], [], self._adb_command_timeout)

                if readable:  # If there's something to read
                    for stream in readable:
                        line = stream.readline()
                        if line:
                            # If the line is non-empty
                            lines.append(line)
                        else:
                            # empty line might indicate the end
                            return ''.join(lines).strip()
                else:
                    # Timeout reached with no output
                    break

            return ''.join(lines).strip()

        except Exception as e:
            # Handle exceptions related to the process communication
            return f"Failed to execute command: {e}"

    def execute_transient_command(self, command) -> Optional[str]:
        try:
            adb_process = subprocess.run(
                [
                    shutil.which('adb'),
                    '-s',
                    self._id,
                    'shell',
                    command
                ], 
                stdin=subprocess.PIPE, 
                stdout=subprocess.PIPE, 
                stderr=subprocess.PIPE, 
                text=True,  # Use text mode for strings
                bufsize=1  # buffer lines
            )

            # Check for errors in stderr or if the process ended in error
            if adb_process.stderr or adb_process.returncode != 0:
                logging.error(f"Command failed with error: {adb_process.stderr}")

            return adb_process.stdout.strip() + adb_process.stderr.strip()
        except Exception as e:
            logging.error(f"Failed to execute Android transient command: {e}")
            return None
    
    def http_redirect_enable(self,
                             mobile_proxy_ip: str = '127.0.0.1',
                             mobile_proxy_port: int = 8080,
                             host_proxy_port: int = 8080):
        print(f"Make sure you have a HTTP proxy running on {host_proxy_port}.")
        print("And transparent proxying enabled in the proxy options.")
        print("And a certificate installed for TLS.")

        # Check if proxy is already enabled
        if self._proxy_active:
            return

        # Make sure we are connected for multiple commands
        if not self._adb_process:
            self.connect()

        # Make sure we are root
        self.execute_connected_command('su')

        # Redirect HTTP(s) traffic to proxy
        self.execute_connected_command(
            f'iptables -t nat -A OUTPUT '
            f'-p tcp --dport 80 -j DNAT '
            f'--to-destination {mobile_proxy_ip}:{mobile_proxy_port}'
        )
        self.execute_connected_command(
            f'iptables -t nat -A OUTPUT '
            f'-p tcp --dport 443 -j DNAT '
            f'--to-destination {mobile_proxy_ip}:{mobile_proxy_port}'
        )
        self.execute_connected_command(
            'iptables -t nat -A POSTROUTING '
            '-p tcp -j MASQUERADE --dport 80'
        )
        self.execute_connected_command(
            'iptables -t nat -A POSTROUTING '
            '-p tcp -j MASQUERADE --dport 443'
        )

        # Forward from mobile to the host machine
        subprocess.run(
            [
                shutil.which('adb'),
                '-s', self._id,
                'reverse', f'tcp:{mobile_proxy_port}', f'tcp:{host_proxy_port}'
            ],
            stdin=subprocess.DEVNULL,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL, 
        )

        self._proxy_active = True
        self.disconnect()

    def http_redirect_disable(self,
                             mobile_proxy_ip: str = '127.0.0.1',
                             mobile_proxy_port: int = 8080):
        if not self._proxy_active:
            return

        # Make sure we are connected for multiple commands
        if not self._adb_process:
            self.connect()

        # Make sure we are root
        self.execute_connected_command('su')

        # Remove forwarding from mobile to the host machine
        self.execute_connected_command(
            f'iptables -t nat -D OUTPUT '
            f'-p tcp --dport 80 -j DNAT '
            f'--to-destination {mobile_proxy_ip}:{mobile_proxy_port}'
        )
        self.execute_connected_command(
            f'iptables -t nat -D OUTPUT '
            f'-p tcp --dport 443 -j DNAT '
            f'--to-destination {mobile_proxy_ip}:{mobile_proxy_port}'
        )
        self.execute_connected_command(
            'iptables -t nat -D POSTROUTING '
            '-p tcp -j MASQUERADE --dport 80'
        )
        self.execute_connected_command(
            'iptables -t nat -D POSTROUTING '
            '-p tcp -j MASQUERADE --dport 443'
        )

        # Remove forwarding from mobile to the host machine
        subprocess.run(
            [
                shutil.which('adb'),
                '-s', self._id,
                'reverse', '--remove', f'tcp:{mobile_proxy_port}'
            ],
            stdin=subprocess.DEVNULL,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL, 
        )

        self._proxy_active = False
        self.disconnect()

    def mirror_screen(self):
        try:
            subprocess.Popen(
                [shutil.which('scrcpy'), '--no-audio', '-s', self._id],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                start_new_session=True
            )
        except subprocess.CalledProcessError as e:
            logging.error(f"Failed to mirror {self._id} screen\n{e}")
    
    def shell(self):
        try:
            p = subprocess.Popen([
                shutil.which('adb'),
                '-s',
                self._id,
                'shell'
            ])
            p.communicate()  # Wait for the ADB session to end
            #return p.returncode
        except subprocess.CalledProcessError as e:
            logging.error(f"Failed to run shell\n{e}")

    ############################################################################
    
    def get_os_version(self) -> Optional[str]:
        return self.execute_transient_command('getprop ro.build.version.release')
    
    def get_api_level(self) -> Optional[str]:
        return self.execute_transient_command('getprop ro.build.version.sdk')